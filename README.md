## 运行方式
直接运行` python3 attack.py `

## 运行结果
密码存在guess.txt中

## 遇到的问题
1. 添加关键词之后，会出现一开始能够高速命中测试集，但是后面命中率基本不变的情况。\
原因：现有逻辑中，关键词序列被赋予固定的极高优先级（-1000.0 或 -900.0），导致队列长期被关键词相关变体占据。当关键词相关的密码已大部分命中后，后续生成的仍是冗余的关键词变体，而非关键词的高概率密码被压制，最终命中率停滞。\
解决方案：通过动态调整关键词序列的优先级和限定关键词生成的序列数，在关键词贡献饱和后逐步释放队列资源给非关键词序列。
2. 关键词无论长短，优先级都是一样的
解决方案：根据关键词长短调整优先级
3. 关键词都在前面，要解决关键词在密码中可出现在任意位置，同时避免任务量激增的问题
解决方案：统计密码出现的位置，然后针对性地在高概率位置嵌入关键词。
4. 内存问题，目前只是简单通过“超过一定内存就强制停止”来解决，最后实验应该每个模型都生成相同数量的猜测
  - 优先队列 变成 Sortedlist ，控制队列中的元素数量

## 文件组成
- extract_password.py：提取出密码序列中的常见关键词
- attack.py：主程序入口，运行后会生成密码并存储到 guess.txt 中
- train.py：用于训练马尔可夫链模型，生成不同阶数的状态转移数据。
- guess.py：根据训练好的模型生成具体的猜测密码。
- intel.py：在猜测的基础上增加情报。
- pltshow.py：用于可视化 guess 结果。
- origin.png ：未添加情报时的图像

## 原理
- 口令集训练: **口令集训练的目的是统计出各个字串在训练集中出现的频数。**
    - 统计频数时，对于口令开头字母出现的频率单独进行统计，其余字串的频数均存放在一个字典中。
        - base = {
    "前缀1": {"字符A": 500, "字符B": 300},\
    "前缀2": {"字符C": 200, "字符D": 400},
}
    - 使用了End-Symbol正规化技术，频数统计时也会对口令结束标志符号进行统计。
        - 密码以order个'#'开头，以'\n'结尾
    - 频数统计完成之后，利用Laplace平滑技术来计算概率，然后对每个字串后面出现的字母依据概率值大小进行排序。
    
- 口令集猜测:使用**Sortedlist**的思想来对猜测口令进行存储和遍历。
    - 队列的组成： [优先级, 当前序列, 扩展前缀] 的列表
        - 优先级：概率的负值，用于优先队列排序，值越小（对应原概率越大），优先级越高，越先被取出处理。
        - 当前密码序列：包含起始符号的完整序列（如 '###admin'，其中 '###' 是起始符号）。
        - 扩展前缀：当前序列的最后 order 个字符，用于查询下一个可能的字符。
    - 如果当前队列前端的字符串最后一个字符为口令结束标识符，则将其输出进行口令猜解；否则根据其字串在概率表中的统计情况，在该字符串后继续添加字符并计算概率，然后插入队列。
    - 只有当其概率值大于预设阈值时，才准许插入队列。这是为了减少队列对内存的损耗。